# Cvičení 06

## Záznam cvičení 6

++++
<video width="100%"  controls>
  <source src="https://kmlinux.fjfi.cvut.cz/~pauspetr/video/bipa2-2021-cv06.mp4" type="video/mp4">
</video>
++++
https://kmlinux.fjfi.cvut.cz/~pauspetr/video/bipa2-2021-cv06.mp4

# Původní zadání

V dnešním cvičení se seznámíme s použitím **STL** (standard template library) a vyzkoušíme si speciální třídy zvané **funktory**. Ukážeme si některé mírně modifikované příklady z **courses** pro 6. cviko.

### Úkol 1

Vytvořte **funktor** `HashString`. Funktor má za úkol provést výpočet hashe zadaného řetězce. Hash bude odpovídat součtu ASCII hodnot znaků v řetězci. Např.
```c++
HashString hs;
int hash = hs("AA"); // hash = 130
```

### Úkol 2

Vytvořte normální **funkci** `filter_duplicates()`, která přijímá jako parametr `vector` integerů. Tato metoda má za úkol zbavit tento vektor duplicitních hodnot (nechat pouze jeden výskyt hodnoty). Výsledek vrátí v novém vektoru integerů *seřazeném vzestupně*. Např. `filter_duplicates({3, 2, 1, 1, 2, 3, 3, 2, 1});` vrátí vektor obsahující `{1, 2, 3}`.

### Úkol 3

Implementujte normální **funkci** `sort_data()`, která dostane na vstupu `vector` čísel `int`. Na výstupu vraťte `vector` čísel `int`, který bude mít přeuspořádané hodnoty tak, že čísla budou seřazená podle počtu jejich výskytů, pokud se nějaká čísla vyskytují stejněkrát, tak je seřaďte podle jejich hodnot. Např. pro vstup `{1, 4, 1, 7, 4, 5, 7, 7}` bude odpovídající výstup `{7, 7, 7, 1, 1, 4, 4, 5}`, protože číslo `7` se ve vstupním vectoru vyskytovalo nejvícekrát, číslo `1` se vyskytuje stejněkrát jako `4`, ale má nižší hodnotu a číslo `5` se vyskytuje pouze jednou.

### Úkol 4

Vytvořte **funktor** `CompressVector`, který zkomprimuje rozsah čísel.
Vaším úkolem je pro zadanou posloupnost čísel transformovat pole do podoby, že obsahuje pouze čísla v rozsahu
`<n; n+K>` (`K` je počet různých hodnot ve vstupní posloupnosti, `n` je počáteční hodnota zkompresovaného intervalu,
defaultně `n=1`) a kde je dodrženo, že pokud bylo číslo na indexu `i` vyšší, než číslo na indexu `j` ve vstupní posloupnosti,
tak tomu tak bude i v té výstupní. Analogicky, kde byly stejné hodnoty na vstupu, tak musí být stejné i na výstupu.
Např. pro pole `{1, 17, 2000, 13, 1, 2}` by byl odpovídající výstup `{1, 4, 5, 3, 1, 2}` pro `n = 1`.
Například pro `n = 10` by byl výstup `{10, 13, 14, 12, 10, 11}`.

```c++
CompressVector cv;
CompressVector cv10(10);

cv({1, 17, 2000, 13, 1, 2});    // vratí {1, 4, 5, 3, 1, 2}
cv10({1, 17, 2000, 13, 1, 2});  // vrátí {10, 13, 14, 12, 10, 11}
```

### Úkol 5

Pro připravené vektory `v1, v2, v3` proveďte:

* Nahrazení dat ve `v2` druhou polovinou dat z `v1` co nejefektivněji.
* vložení druhé poloviny dat z `v1` za data ve `v3` co nejefektivněji.

## Testovací funkce

Testovací soubor naleznete zase zde v repozitáři.